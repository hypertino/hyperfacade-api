#%RAML 1.0 Library
types:
  HFConditional:
    type: object
    properties:
      if?:

  HFRewriteArguments:
    type: object
    properties:
      location:
      query:
        type: object
        required: false

  HFSetArguments:
    type: object
    properties:
      source:
      target?:
      stages?: string[]

  HFFetchArguments:
    type: object
    properties:
      location:
      query:
        type: object
        required: false
      expects?:
        enum: [document,collection_link,collection_top,single_item]
      on_error?:
        enum: [fail,remove,default]
      default_statuses?: integer[]
      default?:
      stages?: string[]
      selector?:
      always?: boolean

  HFContextFetchArguments:
    type: object
    properties:
      target:
      location:
      query:
        type: object
        required: false
      expects?:
        enum: [document,collection_link,collection_top,single_item]
      on_error?:
        enum: [fail,remove,default]
      default_statuses?: integer[]
      selector?:
      default?:

  HFAnnotationListItem:
    type: object
    properties:
      deny?: [HFConditional | nil]
      remove?: [HFConditional | nil]
      rewrite?: [HFRewriteArguments, HFConditional]
      forward?: [HFRewriteArguments, HFConditional]
      set?: [HFSetArguments, HFConditional]
      fetch?: [HFFetchArguments, HFConditional ]
      context_fetch?: [HFContextFetchArguments, HFConditional]
      extract_item?: [HFConditional | nil]

  HFAnnotationList: HFAnnotationListItem[]

annotationTypes:
  apply: HFAnnotationList
  deny: [HFConditional | nil]
  remove: [HFConditional | nil]
  rewrite: [HFRewriteArguments, HFConditional]
  forward: [HFRewriteArguments, HFConditional]
  set: [HFSetArguments, HFConditional]
  fetch: [HFFetchArguments, HFConditional ]
  context_fetch: [HFContextFetchArguments, HFConditional]
  extract_item: [HFConditional | nil]

